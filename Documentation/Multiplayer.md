# Multiplayer
One of the key elements this showcase provides is an understanding of how to quickly integrate key multiplayer features from the platform to build a project where it's easy to interact with others.

## Player to Lobby Options
There are two different ways to join or create a game in <i>Decommissioned:</i> Quick Match and Private Match.

<div><img src="./Media/MainMenuArcade.png" width="500"></div>

### Quick Match
The Quick Match button will start a flow where we will try to join a random room as a client through the random room photon API. If we don't find one, we then start a new room as a host.

Anyone can join a public match before it begins as long as there is space available. If all available rooms are full, a new room will be created by the player attempting to join.

### Private Match
This creates a private room. From here, only users who recieve invites through the Meta Platform may join the match.

## Navigation flow
The core element of navigation is the [MainMenu](../Assets/Decommissioned/Scripts/App/MainMenu.cs). This script encapsulates API for navigating through the application; in short, it will start the connection flow through the [NetworkLayer](../Packages/com.meta.multiplayer.netcode-photon/Networking/NetworkLayer.cs) using the [Application.Core](../Assets/Decommissioned/Scripts/App/Application.Core.cs) and [Application.Oculus](../Assets/Decommissioned/Scripts/App/Application.Oculus.cs) scripts.

The Application.Core script handles the change of network state. When a player is connected or disconnected, the Application.Oculus script handles the configuration required to place them in an appropriate room with the proper [GroupPresenceState](../Packages/com.meta.multiplayer.netcode-photon/Core/GroupPresenceState.cs).

Upon connection, we will also navigate to the [Lobby scene](../Assets/Decommissioned/Scenes/Lobby.unity) using the [SceneLoader](../Packages/com.meta.multiplayer.netcode-photon/Core/SceneLoader.cs). The scene loader handles the state of the scenes and how to handle scene navigation using netcode. When connected through netcode, we use Netcode's [NetworkSceneManager](../Packages/com.unity.netcode.gameobjects/Runtime/SceneManagement/NetworkSceneManager.cs), which synchronizes the current Unity scene between connected users.

## Invitations
When the user recieves an invitation at any time (whether they have already launched the game or not). The intent generated by this process is handled in [Application.Oculus](../Assets/Decommissioned/Scripts/App/Application.Oculus.cs).

We check the information of the intent and trigger the proper navigation flow based on that information. For this project, the core information needed is the lobbySessionId, which is used as the name of the room we wish to join.

## Voip
[VoipController](../Packages/com.meta.multiplayer.netcode-photon/Core/VoipController.cs) handles the setup of the voip speaker and recorder for the players. The recorder will record the local player voice and send it through the network where, on the other client, a speaker will be created to play the received sound. It also handles checking permission to record audio from the platform.  

[VoipHandler](../Packages/com.meta.multiplayer.netcode-photon/Core/VoipHandler.cs) keeps track of the recorder or the speaker of a given entity. This makes it easier to mute and unmute the speaker or stop and start recording by keeping a reference to the recorder and speaker. This is used by the muting behaviour detailed below.

### Muting
As players are moved to different locations throughout a match, the state of each player's voice chat (muted/unmuted) may change based on how many players are in their immediate vicinity. This state is accessed and changed by various components through [PlayerVoip](../Assets/Decommissioned/Scripts/Player/PlayerVoip.cs).

## Group Presence
As mentioned above, we set the group presence when the user changes scene and networked room so that others can easily join them. The main implementation is done in [GroupPresenceState](../Packages/com.meta.multiplayer.netcode-photon/Core/GroupPresenceState.cs), which implements the group presence API
and keeps the state locally for reference.

## Photon with Netcode for GameObject
To develop this project, we used [Netcode for GameObjects](https://github.com/Unity-Technologies/com.unity.netcode.gameobjects) with the [Photon Realtime Transport](https://github.com/Unity-Technologies/multiplayer-community-contributions/tree/main/Transports/com.community.netcode.transport.photon-realtime). Specifically, we used the fork of the transport package from [Ultimate Glove Ball](https://github.com/oculus-samples/Unity-UltimateGloveBall/tree/main/Packages/com.community.netcode.transport.photon-realtime%40b28923aa5d).

The additions made in the fork include:

* Add intent on connection, either as client, host, or to the lobby. [PhotonRealtimeTransport](https://github.com/oculus-samples/Unity-UltimateGloveBall/tree/main/Packages/com.community.netcode.transport.photon-realtime%40b28923aa5d/Runtime/PhotonRealtimeTransport.cs)
* Add private room, where we set the visible flag when we create a room.
* Add region override in order to be able to change regions.
* Support join random room failure. [PhotonRealtimeTransport.MatchMaking](https://github.com/oculus-samples/Unity-UltimateGloveBall/tree/main/Packages/com.community.netcode.transport.photon-realtime%40b28923aa5d/Runtime/PhotonRealtimeTransport.Matchmaking.cs)
* Add function call to handle room creation with parameters. The parameters getter function can be hooked to the [PhotonRealtimeTransport.Connection](https://github.com/oculus-samples/Unity-UltimateGloveBall/tree/main/Packages/com.community.netcode.transport.photon-realtime%40b28923aa5d/Runtime/PhotonRealtimeTransport.Connection.cs) at runtime and gives full ownership to the project on how to create the rooms.
